#!/bin/bash

# ServerWatch - Network Server Monitoring Daemon
# Usage: ./serverwatch <COMMAND> <IP_ADDRESS> [OPTIONS]

SCRIPT_NAME="serverwatch"
VERSION="2.2"
PID_DIR="/tmp"
PID_FILE="$PID_DIR/$SCRIPT_NAME.pid"
DEFAULT_LOG_DIR="$HOME/.serverwatch"

# Color codes for terminal output (only used in foreground mode)
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default settings
PING_INTERVAL=30
PING_TIMEOUT=5
ALERT_AFTER_FAILURES=3
FOREGROUND=false
VERBOSE=false
SERVER_IP=""

# Ensure log directory exists
mkdir -p "$DEFAULT_LOG_DIR"

# Function to show usage
show_usage() {
    echo "ServerWatch v$VERSION - Network Server Monitoring Daemon"
    echo ""
    echo "Usage: $0 <COMMAND> [IP_ADDRESS] [OPTIONS]"
    echo ""
    echo "COMMANDS:"
    echo "  start <IP>     Start monitoring in background (default)"
    echo "  stop           Stop the monitoring daemon"
    echo "  restart <IP>   Restart the monitoring daemon"
    echo "  status         Show daemon status"
    echo "  log            Show live log output (tail -f)"
    echo "  report         Show monitoring statistics"
    echo ""
    echo "OPTIONS:"
    echo "  -f, --foreground   Run in foreground (visible mode)"
    echo "  -v, --verbose      Verbose logging (log every check)"
    echo "  -i INTERVAL        Ping interval in seconds (default: 30)"
    echo "  -t TIMEOUT         Ping timeout in seconds (default: 5)"
    echo "  -a ALERT           Alert after N consecutive failures (default: 3)"
    echo "  -d DIR             Log directory (default: ~/.serverwatch)"
    echo ""
    echo "EXAMPLES:"
    echo "  $0 start 192.168.1.100              # Start monitoring in background"
    echo "  $0 start 192.168.1.100 -f           # Start monitoring in foreground"
    echo "  $0 start 192.168.1.100 -v           # Verbose logging"
    echo "  $0 start 192.168.1.100 -i 10        # Check every 10 seconds"
    echo "  $0 stop                              # Stop monitoring"
    echo "  $0 status                            # Check if monitoring is running"
    echo "  $0 log                               # Watch live logs"
    exit 1
}

# Function to check if daemon is running
is_running() {
    if [ -f "$PID_FILE" ]; then
        PID=$(cat "$PID_FILE")
        if ps -p "$PID" > /dev/null 2>&1; then
            return 0
        else
            # PID file exists but process is not running
            rm -f "$PID_FILE"
            return 1
        fi
    fi
    return 1
}

# Function to get monitored IP from running daemon
get_monitored_ip() {
    if [ -f "$DEFAULT_LOG_DIR/.current_target" ]; then
        cat "$DEFAULT_LOG_DIR/.current_target"
    else
        echo "unknown"
    fi
}

# Parse command
if [ $# -lt 1 ]; then
    show_usage
fi

COMMAND=$1
shift

# Handle commands that don't need IP
case $COMMAND in
    stop)
        if is_running; then
            PID=$(cat "$PID_FILE")
            echo -e "${YELLOW}Stopping ServerWatch daemon (PID: $PID)...${NC}"
            kill "$PID"
            sleep 2
            if is_running; then
                echo -e "${RED}Failed to stop daemon gracefully, forcing...${NC}"
                kill -9 "$PID"
            fi
            rm -f "$PID_FILE"
            rm -f "$DEFAULT_LOG_DIR/.current_target"
            echo -e "${GREEN}ServerWatch daemon stopped${NC}"
        else
            echo -e "${YELLOW}ServerWatch is not running${NC}"
        fi
        exit 0
        ;;
    
    status)
        if is_running; then
            PID=$(cat "$PID_FILE")
            TARGET=$(get_monitored_ip)
            echo -e "${GREEN}● ServerWatch is running${NC}"
            echo "  PID: $PID"
            echo "  Monitoring: $TARGET"
            echo "  Log file: $DEFAULT_LOG_DIR/monitor.log"
            
            # Show statistics if available
            if [ -f "$DEFAULT_LOG_DIR/stats.json" ]; then
                echo ""
                echo "Statistics:"
                grep -E '"(uptime_percent|total_checks|total_failures|last_status|network_state)"' "$DEFAULT_LOG_DIR/stats.json" | while read line; do
                    echo "  $line"
                done
            fi
            
            # Show last few log entries
            if [ -f "$DEFAULT_LOG_DIR/monitor.log" ]; then
                echo ""
                echo "Recent activity:"
                tail -5 "$DEFAULT_LOG_DIR/monitor.log" | while read line; do
                    echo "  $line"
                done
            fi
        else
            echo -e "${RED}● ServerWatch is not running${NC}"
        fi
        exit 0
        ;;
    
    log)
        if [ -f "$DEFAULT_LOG_DIR/monitor.log" ]; then
            echo "Showing live log (Ctrl+C to exit)..."
            echo "---"
            tail -f "$DEFAULT_LOG_DIR/monitor.log"
        else
            echo -e "${RED}No log file found${NC}"
        fi
        exit 0
        ;;
    
    report)
        if [ -f "$DEFAULT_LOG_DIR/stats.json" ]; then
            echo "=== ServerWatch Statistics ==="
            cat "$DEFAULT_LOG_DIR/stats.json"
            echo ""
            echo "=============================="
        else
            echo -e "${YELLOW}No statistics available yet${NC}"
        fi
        exit 0
        ;;
    
    start|restart)
        if [ "$COMMAND" = "restart" ]; then
            if is_running; then
                PID=$(cat "$PID_FILE")
                echo "Restarting ServerWatch daemon..."
                kill "$PID"
                sleep 2
                rm -f "$PID_FILE"
            fi
        fi
        
        # Need IP for start/restart
        if [ $# -lt 1 ]; then
            echo -e "${RED}Error: IP address required for $COMMAND command${NC}"
            show_usage
        fi
        SERVER_IP=$1
        shift
        ;;
    
    *)
        echo -e "${RED}Error: Unknown command '$COMMAND'${NC}"
        show_usage
        ;;
esac

# Parse options
while [[ $# -gt 0 ]]; do
    case $1 in
        -f|--foreground)
            FOREGROUND=true
            shift
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -i)
            PING_INTERVAL=$2
            shift 2
            ;;
        -t)
            PING_TIMEOUT=$2
            shift 2
            ;;
        -a)
            ALERT_AFTER_FAILURES=$2
            shift 2
            ;;
        -d)
            DEFAULT_LOG_DIR=$2
            mkdir -p "$DEFAULT_LOG_DIR"
            shift 2
            ;;
        *)
            echo -e "${RED}Error: Unknown option '$1'${NC}"
            show_usage
            ;;
    esac
done

# Validate IP address
if ! [[ $SERVER_IP =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
    echo -e "${RED}Error: Invalid IP address format${NC}"
    exit 1
fi

# Check if already running
if is_running; then
    echo -e "${YELLOW}ServerWatch is already running (PID: $(cat $PID_FILE))${NC}"
    echo "Use '$0 restart $SERVER_IP' to restart with new target"
    exit 1
fi

# Set up log files
LOG_FILE="$DEFAULT_LOG_DIR/monitor.log"
STATS_FILE="$DEFAULT_LOG_DIR/stats.json"
ERROR_LOG="$DEFAULT_LOG_DIR/error.log"

# Save configuration
cat > "$DEFAULT_LOG_DIR/.config" << EOF
{
  "verbose": $VERBOSE,
  "interval": $PING_INTERVAL,
  "timeout": $PING_TIMEOUT
}
EOF

# Main monitoring function
monitor_server() {
    # Save current target
    echo "$SERVER_IP" > "$DEFAULT_LOG_DIR/.current_target"
    
    # Initialize counters
    local consecutive_failures=0
    local total_checks=0
    local total_failures=0
    local total_successes=0
    local start_time=$(date +%s)
    local last_status="unknown"
    local status_changed=false
    
    # Network detection variables
    local network_state="unknown"
    local last_network_state="unknown"
    local checks_while_away=0
    local AWAY_CHECK_INTERVAL=3600  # 1 hour when away from home
    local last_away_check=0
    
    # Function to check if on home network or VPN
    is_connected_to_home() {
        # Check 1: Are we on the home network IP range (192.168.178.x)?
        # This works whether connected via WiFi or Ethernet
        if ifconfig | grep -q "inet 192.168.178"; then
            echo "home-network"
            return 0
        fi
    
        # Check 2: VPN via scutil
        if command -v scutil &> /dev/null; then
            if scutil --nc list | grep "(Connected)" | grep -q "vpn@ajs"; then
                echo "vpn"
                return 0
            fi
        fi
    
        # Check 3: WiFi SSID (fallback)
        AIRPORT="/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport"
        if [ -x "$AIRPORT" ]; then
            local ssid
            ssid=$("$AIRPORT" -I 2>/dev/null | awk '/ SSID/ {print substr($0, index($0, $2))}')
            if [[ "$ssid" == "AJS Net" ]]; then
                echo "wifi"
                return 0
            fi
        fi
    
        echo "not-connected"
        return 1
    }
    
    # Calculate appropriate log frequency based on interval
    local log_frequency=20
    if [ "$PING_INTERVAL" -le 5 ]; then
        log_frequency=60  # Log every minute for fast intervals
    elif [ "$PING_INTERVAL" -le 15 ]; then
        log_frequency=20  # Log every 20 checks for medium intervals
    else
        log_frequency=10  # Log every 10 checks for slow intervals
    fi
    
    # Override if verbose mode
    if [ "$VERBOSE" = true ]; then
        log_frequency=1  # Log every check in verbose mode
    fi
    
    # Log function for background mode
    log_message() {
        local level=$1
        local message=$2
        local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        echo "$timestamp [$level] $message" >> "$LOG_FILE"
        
        # Also echo to stdout if in foreground mode
        if [ "$FOREGROUND" = true ]; then
            case $level in
                ERROR)   echo -e "${RED}[$timestamp] ✗ $message${NC}" ;;
                SUCCESS) echo -e "${GREEN}[$timestamp] ✓ $message${NC}" ;;
                WARNING) echo -e "${YELLOW}[$timestamp] ⚠ $message${NC}" ;;
                INFO)    echo -e "${BLUE}[$timestamp] ℹ $message${NC}" ;;
                *)       echo "[$timestamp] $message" ;;
            esac
        fi
    }
    
    # Calculate response time
    get_response_time() {
        local start=$(date +%s%N)
        if ping -c 1 -W "$PING_TIMEOUT" "$SERVER_IP" > /dev/null 2>&1; then
            local end=$(date +%s%N)
            local ms=$(( (end - start) / 1000000 ))
            echo "$ms"
            return 0
        else
            return 1
        fi
    }
    
    # Update statistics file
    update_stats() {
        local current_time=$(date +%s)
        local duration=$((current_time - start_time))
        local uptime_percent=100
        if [ $total_checks -gt 0 ]; then
            uptime_percent=$(( (total_checks - total_failures) * 100 / total_checks ))
        fi
        
        # Format duration
        local hours=$((duration / 3600))
        local minutes=$(( (duration % 3600) / 60 ))
        
        cat > "$STATS_FILE" << EOF
{
  "target": "$SERVER_IP",
  "start_time": "$start_time",
  "duration_seconds": $duration,
  "duration_formatted": "${hours}h ${minutes}m",
  "total_checks": $total_checks,
  "total_successes": $total_successes,
  "total_failures": $total_failures,
  "consecutive_failures": $consecutive_failures,
  "uptime_percent": $uptime_percent,
  "last_check": "$(date '+%Y-%m-%d %H:%M:%S')",
  "last_status": "$last_status",
  "network_state": "$network_state",
  "check_interval": $PING_INTERVAL,
  "verbose_mode": $VERBOSE
}
EOF
    }
    
    # Send alert function
    send_alert() {
        local message=$1
        log_message "ALERT" "$message"
        
        # macOS notification (if available and in background mode)
        if [ "$FOREGROUND" = false ] && command -v osascript &> /dev/null; then
            osascript -e "display notification \"$message\" with title \"ServerWatch Alert\" sound name \"Sosumi\"" 2>/dev/null
        fi
    }
    
    # Signal handler for cleanup
    cleanup() {
        log_message "INFO" "Monitoring stopped (PID: $$, Total checks: $total_checks, Uptime: $((total_successes * 100 / (total_checks + 1)))%)"
        update_stats
        rm -f "$PID_FILE"
        rm -f "$DEFAULT_LOG_DIR/.current_target"
        rm -f "$DEFAULT_LOG_DIR/.config"
        exit 0
    }
    
    trap cleanup SIGTERM SIGINT
    
    # Initial log entries
    log_message "INFO" "ServerWatch v$VERSION started (PID: $$)"
    log_message "INFO" "Monitoring $SERVER_IP (interval: ${PING_INTERVAL}s, timeout: ${PING_TIMEOUT}s, verbose: $VERBOSE)"
    
    # Main monitoring loop
    while true; do
        # Check network/VPN connection status
        connection_type=$(is_connected_to_home)
        
        if [[ "$connection_type" == "not-connected" ]]; then
            # Not on home network or VPN
            if [ "$network_state" != "away" ]; then
                # Just changed to away state
                network_state="away"
                log_message "WARNING" "📡 Not on home network or VPN - reducing check frequency to once per hour"
                checks_while_away=0
            fi
            
            # Check if it's time for an away check
            local current_time=$(date +%s)
            if [ $((current_time - last_away_check)) -lt $AWAY_CHECK_INTERVAL ]; then
                # Not time yet, sleep for a minute and check network again
                sleep 60
                continue
            fi
            
            last_away_check=$current_time
            checks_while_away=$((checks_while_away + 1))
            log_message "INFO" "⏰ Performing hourly check while away (#$checks_while_away)"
            
        else
            # Connected to home network or VPN
            if [ "$network_state" != "home" ]; then
                # Just changed to home state
                network_state="home"
                case "$connection_type" in
                    wifi)
                        log_message "SUCCESS" "📡 Connected to home WiFi 'AJS Net' - resuming normal monitoring"
                        ;;
                    vpn)
                        log_message "SUCCESS" "🔒 Connected via VPN 'vpn@ajs' - resuming normal monitoring"
                        ;;
                    *)
                        log_message "SUCCESS" "📡 Connected to home network - resuming normal monitoring"
                        ;;
                esac
                checks_while_away=0
            fi
        fi
        
        # Now perform the actual server check
        total_checks=$((total_checks + 1))
        
        # Perform ping and measure response time
        if response_time=$(get_response_time); then
            # Server is up
            total_successes=$((total_successes + 1))
            
            if [ "$last_status" = "offline" ] || [ "$last_status" = "unknown" ]; then
                # Recovery detected or first successful check
                log_message "SUCCESS" "Server $SERVER_IP is ONLINE (${response_time}ms response time)"
                if [ $consecutive_failures -gt 0 ]; then
                    send_alert "Server $SERVER_IP recovered after $consecutive_failures failures!"
                fi
                consecutive_failures=0
                status_changed=true
            elif [ "$VERBOSE" = true ] || [ $((total_checks % log_frequency)) -eq 0 ]; then
                # Log periodic success
                local connection_info=""
                if [ "$network_state" = "away" ]; then
                    connection_info=" [checking while away]"
                fi
                log_message "SUCCESS" "Server responding (check #$total_checks, ${response_time}ms, uptime: $((total_successes * 100 / total_checks))%)$connection_info"
            fi
            
            last_status="online"
        else
            # Server is down
            consecutive_failures=$((consecutive_failures + 1))
            total_failures=$((total_failures + 1))
            
            if [ "$last_status" = "online" ] || [ "$last_status" = "unknown" ]; then
                # First failure after being online
                log_message "ERROR" "Server $SERVER_IP is OFFLINE (check #$total_checks)"
                status_changed=true
            else
                # Continued failure
                local connection_info=""
                if [ "$network_state" = "away" ]; then
                    connection_info=" [checking while away]"
                fi
                log_message "ERROR" "Server still unreachable (failure #$consecutive_failures, total: $total_failures)$connection_info"
            fi
            
            last_status="offline"
            
            # Send alerts at specific thresholds (but only if we're on home network)
            if [ "$network_state" = "home" ]; then
                if [ $consecutive_failures -eq $ALERT_AFTER_FAILURES ]; then
                    send_alert "⚠️ Server $SERVER_IP has been DOWN for $consecutive_failures consecutive checks!"
                elif [ $consecutive_failures -gt $ALERT_AFTER_FAILURES ] && [ $((consecutive_failures % 10)) -eq 0 ]; then
                    send_alert "🚨 Server $SERVER_IP still down ($consecutive_failures consecutive failures)"
                fi
            fi
        fi
        
        # Update statistics more frequently for short intervals or on status change
        if [ $((total_checks % 5)) -eq 0 ] || [ "$status_changed" = true ] || [ "$PING_INTERVAL" -le 5 ]; then
            update_stats
            status_changed=false
        fi
        
        # Sleep for the configured interval (unless we're away, then the sleep is handled above)
        if [ "$network_state" = "home" ]; then
            sleep "$PING_INTERVAL"
        fi
    done
}

# Start the monitoring
if [ "$FOREGROUND" = true ]; then
    # Run in foreground
    echo "==================================="
    echo "    ServerWatch v$VERSION"
    echo "==================================="
    echo "Target Server: $SERVER_IP"
    echo "Mode: Foreground (visible)"
    echo "Verbose: $VERBOSE"
    echo "Interval: ${PING_INTERVAL}s"
    echo "Timeout: ${PING_TIMEOUT}s"
    echo "Log Directory: $DEFAULT_LOG_DIR"
    echo "==================================="
    echo ""
    monitor_server
else
    # Run in background (daemon mode)
    echo -e "${GREEN}Starting ServerWatch daemon...${NC}"
    echo "Target: $SERVER_IP"
    echo "Interval: ${PING_INTERVAL}s"
    echo "Verbose: $VERBOSE"
    echo "Logs: $DEFAULT_LOG_DIR"
    
    # Start monitoring in background
    monitor_server > "$ERROR_LOG" 2>&1 &
    DAEMON_PID=$!
    
    # Save PID
    echo $DAEMON_PID > "$PID_FILE"
    
    sleep 1
    
    # Verify it started successfully
    if is_running; then
        echo -e "${GREEN}✓ ServerWatch started successfully (PID: $DAEMON_PID)${NC}"
        echo ""
        echo "Commands:"
        echo "  View logs:    $0 log"
        echo "  Check status: $0 status"
        echo "  Stop daemon:  $0 stop"
        
        if [ "$VERBOSE" = true ]; then
            echo ""
            echo -e "${YELLOW}Note: Verbose mode enabled - logs will be more detailed${NC}"
        fi
    else
        echo -e "${RED}✗ Failed to start ServerWatch${NC}"
        echo "Check error log: $ERROR_LOG"
        exit 1
    fi
fi